# PeakLIMS UI

Every time you chose to apply one or more rules, explicitly state the rule(s) in the output. You can abbreviate the rule description to a single word or phrase. Request or verify any missing or ambiguous context before proceeding with a response.

## Project Context

A LIMS application to help laboratory staff manage their date with ease, accelerating their day to day so they can have a smooth and efficient workflow with a modern UX.

- Manages patient and accession info along with all the metadata associated with them
- Manages run data for the lab
- Manages the reporting of the data, including creation and sending

## Code Style and Structure

- Write concise, technical TypeScript code with accurate examples
- Use functional and declarative programming patterns; avoid classes unless for a rich domain model which should operate with a fluent and functional api.
- Prefer iteration and modularization over code duplication when duplication is >2x
- Use descriptive variable names with auxiliary verbs (e.g., isLoading, hasError)
- Booleans like `isSuccessful` should generally be derived from a richer variable like `isSuccessful => Status === 'Successful'`
- Favor a vertically sliced architecture whenever possible
- Files and directories should be kebab lower case
- Structure repository files as follows:

```
server/
├── src/
    ├── components/     		# Shared React components
		    ├── svgs/     			# SVG components
      	├── notifications/  # Notifications/toasts
		    ├── file-upload/    # File upload components
		    ├── data-table/     # Components for the data table
		    ├── ui.ts     			# Form based components
		    ├── xxxx.ts     		# components that are not strictly form based live here
    ├── hooks/          		# Custom React hooks shared across the app
    ├── domain/         		# Core entities used in this app for vertical slice grouping
        ├── entity/       	# The entity within the domain that we're working with
    				├── apis/       		# The web apis for this entity
			      ├── components/     # The components specific to this entity
    				├── features/       # The features for ui functionality in the app for the routes to leverage
    				├── types.ts        # The typescript types specific to this entity
    ├── routes/           	# The tanstack route tree for the app
    ├── services/           # Shared global services
    ├── types/          		# Shared TypeScript types globally
    ├── utils/          		# Helper functions
    └── lib/            		# Shared libraries
```

## Tech Stack

- React
- TypeScript
- Tailwind CSS
- Tanstack Query for server state
- Tanstack router for routing (using file based routing)
- Next UI, Shadcn UI, and custom components
- .NET on the backend (in a separate project)

## Naming Conventions

- Use lowercase with dashes for directories (e.g., components/form-wizard)
- Favor named exports for components and utilities. Don't use `default` exports.
- Use PascalCase for component files (e.g., VisaForm.tsx)
- Use camelCase for utility files (e.g., formValidator.ts)

## TypeScript Usage

- Use TypeScript for all code; prefer interfaces over types
- Avoid enums; use const objects with 'as const' assertion
- Use functional components with TypeScript interfaces
- Define strict types for message passing between different parts of the extension
- Use absolute imports for all files @/...
- Avoid try/catch blocks unless there's good reason to translate or handle error in that abstraction
- Use explicit return types for all functions
- Favor `async/await` over `then()` for asynchronous operations.

## State Management

- Server state and any other asynchronous state should always be managed through Tanstack Query
- For client state, default to built in React state with `useState` to state (or `useReducer` if you have several stacked use states that depend on each other and could be coupled to a reducer)
- If you need context, use `useContext` for simple scenarios and `zustand` for complex ones
- Forms should use `react-hook-form`
- Use component composition or context/zustand to minimize prop drilling
- `useEffect` hooks should generally get named abstractions
- Implement proper cleanup in useEffect hooks

### Server State and Tanstack Query

- Query keys should be setup with a factory that has a dependent path for different levels of granularity, for example:

  ```
  const todoKeys = {
    all: ['todos'] as const,
    lists: () => [...todoKeys.all, 'list'] as const,
    list: (filters: string) => [...todoKeys.lists(), { filters }] as const,
    details: () => [...todoKeys.all, 'detail'] as const,
    detail: (id: number) => [...todoKeys.details(), id] as const,
  }
  ```

- Endpoints should live in the `domain/entity/api` directory with a single file per endpoint

  - There should be an exported hook and an internal api call

  - Unless otherwise specified, api calls should use the `peakLimsApi` client at `@/services/api-client`

- While there can and will be various domain specific endpoints, there will also be standard CRUD ones that will be used as well. Here are a few examples

  - A standard POST for creation might look like this:

    ```
    export const addAccessionComment = async (
      data: AccessionCommentForCreationDto
    ) => {
      return peakLimsApi
        .post(`/v1/accessionComments`, data)
        .then((response) => response.data);
    };

    type CommentMutationContext = {
      accessionId: string;
    };

    export interface AddCommentProps {
      data: AccessionCommentForCreationDto;
    }

    export function useAddAccessionComment(
      options?: UseMutationOptions<
        void,
        AxiosError,
        AddCommentProps,
        CommentMutationContext
      >
    ) {
      const queryClient = useQueryClient();
      return useMutation({
        mutationFn: ({ data }: AddCommentProps) => addAccessionComment(data),
        onMutate: (variables) => {
          return { accessionId: variables.data.accessionId };
        },
        onSuccess: (_, __, context: CommentMutationContext | undefined) => {
          if (context) {
            queryClient.invalidateQueries({
              queryKey: AccessionCommentKeys.byAccession(context.accessionId!)
            });
          }
        },
        ...options,
      });
    }
    ```

  - A standard GET for an individual entity might look like this:

    ```
    export const getAccessionComment = async (accessionId: string) => {
      return peakLimsApi
        .get(`/v1/accessionComments/byAccession/${accessionId}`)
        .then((response: AxiosResponse<AccessionCommentViewDto>) => response.data);
    };

    export const useGetAccessionComment = (accessionId: string | undefined) => {
      return useQuery({
        queryKey: AccessionCommentKeys.byAccession(accessionId!),
        queryFn: () => getAccessionComment(accessionId!),
        enabled: accessionId !== null && accessionId !== undefined,
      });
    };
    ```

  - A standard GET for an entity wordlist might look like this:

    ```
    interface delayProps {
      hasArtificialDelay?: boolean;
      delayInMs?: number;
    }

    interface AccessionListApiProps extends delayProps {
      queryString: string;
    }
    const getAccessions = async ({
      queryString,
      hasArtificialDelay,
      delayInMs,
    }: AccessionListApiProps) => {
      queryString = queryString?.length <= 0 ? queryString : `?${queryString}`;

      delayInMs = hasArtificialDelay ? delayInMs : 0;

      const [json] = await Promise.all([
        peakLimsApi
          .get(`/v1/accessions/worklist${queryString}`)
          .then((response: AxiosResponse<AccessionWorklistDto[]>) => {
            return {
              data: response.data as AccessionWorklistDto[],
              pagination: JSON.parse(
                response.headers["x-pagination"] ?? ""
              ) as Pagination,
            } as PagedResponse<AccessionWorklistDto>;
          }),
        new Promise((resolve) => setTimeout(resolve, delayInMs)),
      ]);
      return json;
    };

    interface AccessionListHookProps extends QueryParams, delayProps {}
    export const useAccessioningWorklist = ({
      pageNumber,
      pageSize,
      filters,
      sortOrder,
      delayInMs = 0,
    }: AccessionListHookProps = {}) => {
      const sortOrderString = generateSieveSortOrder(sortOrder);
      const queryParams = queryString.stringify({
        pageNumber,
        pageSize,
        filters,
        sortOrder: sortOrderString,
      });
      const hasArtificialDelay = delayInMs > 0;

      return useQuery({
        queryKey: AccessionKeys.list(queryParams ?? ""),
        queryFn: () =>
          getAccessions({
            queryString: queryParams,
            hasArtificialDelay,
            delayInMs,
          }),
        gcTime: 1000 * 60 * 0.125,
      });
    };

    // TODO: add tests
    export const generateSieveSortOrder = (sortOrder: SortingState | undefined) =>
      sortOrder && sortOrder.length > 0
        ? sortOrder?.map((s) => (s.desc ? `-${s.id}` : s.id)).join(",")
        : undefined;
    ```

  - A standard PUT for an individual entity update might look like this:

    ```
    export const updateAccessionComment = async (
      commentId: string,
      newComment: string
    ) => {
      return peakLimsApi
        .put(`/v1/accessionComments/${commentId}`, { comment: newComment })
        .then((response) => response.data);
    };

    type CommentMutationContext = {
      accessionId: string;
    };

    export interface AddCommentProps {
      accessionId: string;
      commentId: string;
      newComment: string;
    }

    export function useUpdateAccessionComment(
      options?: UseMutationOptions<
        void,
        AxiosError,
        AddCommentProps,
        CommentMutationContext
      >
    ) {
      const queryClient = useQueryClient();
      return useMutation({
        mutationFn: ({ accessionId, commentId, newComment }: AddCommentProps) =>
          updateAccessionComment(commentId, newComment),
        onMutate: (variables) => {
          return { accessionId: variables.accessionId };
        },
        onSuccess: (_, __, context: CommentMutationContext | undefined) => {
          if (context) {
            queryClient.invalidateQueries({
              queryKey: AccessionCommentKeys.byAccession(context.accessionId!)
            });
          }
        },
        ...options,
      });
    }
    ```

## Syntax and Formatting

- Use "function" keyword for pure functions
- Avoid unnecessary curly braces in conditionals
- Use declarative JSX
- Implement proper TypeScript discriminated unions for message types

## UI and Styling

- Use Shadcn UI and Radix for components
- use `npx shadcn@latest add <component-name>` to add new shadcn components
- Implement Tailwind CSS for styling
- Consider extension-specific constraints (popup dimensions, permissions)

## Error Handling

- Implement proper error boundaries
- Provide user-friendly error messages
- If there is not a good way to show an issue (e.x. form validation error by an input), use notifications to show users feedback on errors or during issues
- Handle network failures gracefully and use notifications as needed

## Testing

- ~~Write unit tests for utilities and components~~
- ~~Implement E2E tests for critical flows~~

## Security

-

## Git Usage

Commit Message Prefixes:

- "fix:" for bug fixes
- "feat:" for new features
- "perf:" for performance improvements
- "docs:" for documentation changes
- "style:" for formatting changes
- "refactor:" for code refactoring
- "test:" for adding missing tests
- "chore:" for maintenance tasks

Rules:

- Use lowercase for commit messages
- Keep the summary line concise
- Include description for non-obvious changes
- Reference issue numbers when applicable

## Documentation

- Maintain clear README with setup instructions
- Document API interactions and data flows
- Keep manifest.json well-documented
- Don't include comments unless it's for complex logic
- Document permission requirements

## Development Workflow

-
